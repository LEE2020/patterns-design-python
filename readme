strategy：多用组合，少用继承。
observer: 定义对象之间一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会接到通知并自动更新。(交互系统之间的松耦合）
decorate: 对扩展开放，对修改关闭。动态地将责任附加到对象上，想要扩展功能，装饰器提供有别于继承的另一种选择。
factory: 定义创建对象的接口，但由子类决定要实例化的类是哪一个。工厂模式，将实例化推迟到子类。(要依赖抽象，不依赖具体类）-> 依赖倒置。
singleton: 确保一个类只有一个实例，并提供一个全局的访问点。（对资源敏感的对象尤其重要）
command : 将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持撤销操作。
adapter : 将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。
facade: 让接口更简单。提供了一个统一的接口，用来访问子系统中一群接口。外观定义了一个高层接口，让子系统更容易使用。
prototype: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
iterator: 提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示。














