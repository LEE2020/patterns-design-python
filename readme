OO 原则：
封装变化
多用组合，少用继承
针对接口编程，不针对实现编程
为交互对象之间的松耦合设计而努力
类应该对扩展开放，对修改关闭
依赖抽象，不依赖具体类
只和朋友交谈
别找我，我会找你
类应该只有一个改变的理由（承担一个责任）



（常用做法）模式：在某种context下，针对某问题的某种解决方案。

strategy(策略模式）：多用组合，少用继承。
observer（观察者模式）: 定义对象之间一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会接到通知并自动更新。(交互系统之间的松耦合）
decorate（装饰器模式）: 对扩展开放，对修改关闭。动态地将责任附加到对象上，想要扩展功能，装饰器提供有别于继承的另一种选择。
factory（工厂模式）: 定义创建对象的接口，但由子类决定要实例化的类是哪一个。工厂模式，将实例化推迟到子类。(要依赖抽象，不依赖具体类）-> 依赖倒置。
abstract factory(抽象工厂模式）： 允许客户创建对象家族，而无需指定他们的具体类。
singleton（单例模式）: 确保一个类只有一个实例，并提供一个全局的访问点。（对资源敏感的对象尤其重要）
command（命令模式） : 将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持撤销操作。
adapter（适配器模式） : 将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。
facade（外观模式）: 让接口更简单。提供了一个统一的接口，用来访问子系统中一群接口。外观定义了一个高层接口，让子系统更容易使用。
templatemodel（模版模式）: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
iterator（迭代器模式）: 提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示。
composite(组合模式）： 允许你将对象组合成树形结构来表现“整体/部分” 层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
state (状态模式）：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
proxy(代理模式） ： 为另一个对象提供替身或者占位符，以控制对这个对象的访问。

compond(复合模式）： MVC （ model-view-controller) : 结合两个及两个以上的模式，组成一个解决方案，解决一再发生的一般性问题。









